<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Эхо Башни · демо</title>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            margin: 0;
            padding: 0;
        }
        body {
            min-height: 100vh;
            background: #0b0e14;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            touch-action: manipulation;
            margin: 0;
            padding: 12px;
        }
        .game-wrapper {
            background: #1a1f2b;
            border-radius: 42px;
            padding: 18px;
            box-shadow: 0 25px 40px rgba(0,0,0,0.8), inset 0 0 0 1px rgba(255,255,255,0.05);
        }
        canvas {
            display: block;
            width: 100%;
            max-width: 380px;
            height: auto;
            border-radius: 28px;
            background: #10131e;
            box-shadow: inset 0 0 30px #00000055;
            cursor: pointer;
            touch-action: none;
            margin: 0 auto;
        }
        .panel {
            margin-top: 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: #b9c6db;
            font-weight: 500;
            font-size: 0.9rem;
            letter-spacing: 0.3px;
            background: #232a37;
            padding: 12px 18px;
            border-radius: 60px;
            box-shadow: inset 0 2px 3px #0a0c12;
        }
        .status {
            display: flex;
            gap: 20px;
        }
        .status span {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .status i {
            font-style: normal;
            width: 10px;
            height: 10px;
            border-radius: 10px;
            background: currentColor;
        }
        .echo-indicator {
            color: #80cbc4;
            text-shadow: 0 0 6px #4db6ac;
        }
        .live-indicator {
            color: #ffb6a0;
        }
        button {
            background: #323e52;
            border: none;
            color: white;
            font-weight: 600;
            font-size: 0.9rem;
            padding: 8px 18px;
            border-radius: 40px;
            box-shadow: 0 4px 0 #141a24, 0 6px 10px black;
            transition: 0.08s linear;
            cursor: pointer;
            letter-spacing: 0.4px;
            border: 1px solid #5d6f8b;
        }
        button:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #141a24, 0 6px 10px black;
        }
        .hint {
            font-size: 0.75rem;
            color: #6d7c99;
            display: flex;
            gap: 8px;
            margin-top: 8px;
            padding-left: 8px;
        }
        .hint div {
            background: #1f2633;
            padding: 5px 14px;
            border-radius: 30px;
            border: 1px solid #374152;
        }
    </style>
</head>
<body>
<div>
    <div class="game-wrapper">
        <canvas id="gameCanvas" width="380" height="600"></canvas>
        <div class="panel">
            <div class="status">
                <span class="live-indicator"><i style="background: #ff8a6c;"></i> Живая</span>
                <span class="echo-indicator"><i style="background: #6ef0d0;"></i> Эхо</span>
            </div>
            <button id="restartBtn">↻ Восхождение</button>
        </div>
        <div class="hint">
            <div>⬅ тап слева</div>
            <div>➡ тап справа</div>
            <div>⬆ свайп вверх</div>
        </div>
    </div>
    <p style="text-align: center; margin-top: 18px; color: #4d5a73; font-size: 0.8rem;">Эхо повторяет твой путь с задержкой 1.5 сек. Если эхо упадёт — башня дрожит!</p>
</div>
<script>
    (function() {
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const restartBtn = document.getElementById('restartBtn');

        // ---------- фиксированные размеры ----------
        const CANVAS_W = 380, CANVAS_H = 600;

        // ---------- состояние игры ----------
        let live = { x: 180, y: 480, vx: 0, vy: 0, onGround: true, wobbling: false };
        let pathHistory = [];            // массив {x, y, frame}
        const ECHO_DELAY_FRAMES = 45;    // 1.5 сек при 30fps
        let echoPositions = [];           // точки для отрисовки эха (история со смещением)
        let frame = 0;
        let gameOver = false;
        let shake = 0;                    // эффект тряски при падении эха

        // платформы (башня) – красивые светящиеся плиты
        let platforms = [];

        // камера смещается, чтобы игрок был в центре вертикально (но низ привязан)
        let cameraY = 0;

        // инициализация уровня
        function buildTower() {
            platforms = [];
            // генерируем 25 платформ, начиная снизу (y ~ 550) до верха (y ~ 50)
            for (let i = 0; i < 22; i++) {
                let y = 540 - i * 28;      // расстояние по вертикали
                // чередование: то две слева, то одна справа, создаём интересный путь
                let x, width;
                if (i % 3 === 0) {
                    x = 80;                // левая сторона
                    width = 60;
                } else if (i % 3 === 1) {
                    x = 220;               // центр/правая
                    width = 70;
                } else {
                    x = 280;                // правая сторона
                    width = 55;
                }
                // немного хаоса, чтобы было похоже на башню
                if (i > 15) x = 140 + (i%2)*80;
                if (i === 7) { x = 50; width = 70; }   // низкая платформа слева
                if (i === 12) { x = 270; width = 60; }
                if (i === 18) { x = 160; width = 100; } // широкая площадка

                platforms.push({
                    x: x,
                    y: y,
                    w: width,
                    h: 8,
                    // свечение
                    glow: 0.6 + Math.random()*0.3
                });
            }
            // последняя платформа (самая верхняя) чуть ниже верха
            platforms.push({ x: 130, y: 50, w: 100, h: 8, glow: 1.0 });
        }
        buildTower();

        // начать заново (сброс игрока)
        function resetGame() {
            live = { x: 180, y: 490, vx: 0, vy: 0, onGround: true, wobbling: false };
            pathHistory = [];
            echoPositions = [];
            frame = 0;
            gameOver = false;
            shake = 0;
            cameraY = 0;
        }

        // проверка столкновения с платформами (только снизу, просто)
        function applyCollisions() {
            if (gameOver) return;
            const GRAV = 0.5;
            live.vy += GRAV;

            // горизонтальное движение + ограничение по краям
            live.x += live.vx;
            live.x = Math.max(15, Math.min(CANVAS_W - 15, live.x));
            live.vx *= 0.9; // трение

            // вертикальное
            live.y += live.vy;

            // коллизия с платформами
            live.onGround = false;
            for (let p of platforms) {
                // платформа находится ниже центра персонажа (примерно ноги)
                if (live.y + 8 > p.y && live.y - 8 < p.y + p.h) {
                    // проверка попадания по горизонтали
                    if (live.x + 10 > p.x && live.x - 10 < p.x + p.w) {
                        // падает сверху
                        if (live.vy >= 0 && live.y - 8 <= p.y + 2 && live.y + 6 >= p.y) {
                            live.y = p.y - 8;  // ставим на платформу
                            live.vy = 0;
                            live.onGround = true;
                        }
                    }
                }
            }

            // если упал ниже 620 — game over
            if (live.y > 620) {
                gameOver = true;
            }
            // если слишком высоко — тоже фиксируем камеру, но не умираем
        }

        // обработка касаний/событий мыши (упрощённо: имитация клавиш через тапы)
        let touchTarget = null;
        let touchStartY = 0;

        function handleTapLeft() {
            if (gameOver) return;
            // левый прыжок / рывок влево
            if (live.onGround) {
                live.vx = -5;
                live.vy = -7; // небольшой прыжок
                live.onGround = false;
            } else {
                // в воздухе можно чуть шевельнуться
                live.vx = -3;
            }
        }

        function handleTapRight() {
            if (gameOver) return;
            if (live.onGround) {
                live.vx = 5;
                live.vy = -7;
                live.onGround = false;
            } else {
                live.vx = 3;
            }
        }

        function handleSwipeUp() {
            if (gameOver) return;
            // хвататься за уступ (просто подпрыгнуть выше, если на земле, либо рывок вверх)
            if (live.onGround) {
                live.vy = -10; // сильный прыжок
                live.onGround = false;
            } else {
                // иммитация "подтягивания" — небольшой импульс вверх
                live.vy = -6;
            }
        }

        // слушатели событий (мышь + тач)
        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = (e.clientX - rect.left) * scaleX;
            const canvasY = (e.clientY - rect.top) * scaleY;

            if (canvasX < CANVAS_W * 0.33) {
                handleTapLeft();
            } else if (canvasX > CANVAS_W * 0.66) {
                handleTapRight();
            } else {
                // средняя зона — потенциальный свайп, запомним Y для определения свайпа вверх
                touchStartY = canvasY;
                touchTarget = 'center';
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (touchTarget === 'center') {
                // если был центровой тап без движения — считаем как свайп вверх (для удобства)
                handleSwipeUp();
            }
            touchTarget = null;
        });

        // touch-события
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = (touch.clientX - rect.left) * scaleX;
            const canvasY = (touch.clientY - rect.top) * scaleY;

            if (canvasX < CANVAS_W * 0.33) {
                handleTapLeft();
                touchTarget = null;
            } else if (canvasX > CANVAS_W * 0.66) {
                handleTapRight();
                touchTarget = null;
            } else {
                touchStartY = canvasY;
                touchTarget = 'center';
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            if (touchTarget === 'center') {
                e.preventDefault();
                // определяем свайп вверх, если палец сместился вверх больше чем на 15px
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const scaleY = canvas.height / rect.height;
                const canvasY = (touch.clientY - rect.left) * scaleY; // используем clientY корректно
                // пересчитаем правильно clientY -> canvasY
                const adjustedY = (touch.clientY - rect.top) * scaleY;
                if (touchStartY - adjustedY > 20) {
                    handleSwipeUp();
                    touchTarget = 'done'; // сбрасываем, чтобы не вызывать повторно
                }
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            if (touchTarget === 'center') {
                // если не было свайпа, но просто тап в центре — расценим как свайп (подтягивание)
                handleSwipeUp();
            }
            touchTarget = null;
        });

        // запрет контекстного меню
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // запись истории и эха
        function updateEcho() {
            if (gameOver) return;

            // запоминаем позицию live каждый кадр
            pathHistory.push({ x: live.x, y: live.y, frame: frame });

            // формируем массив для эха — элементы из истории, отстающие на ECHO_DELAY_FRAMES
            echoPositions = pathHistory.filter(p => (frame - p.frame) >= ECHO_DELAY_FRAMES);

            // проверка падения эха: возьмём последнюю точку эха (самую свежую) и проверим, не провалилась ли она
            if (echoPositions.length > 0) {
                // сортировка по убыванию frame, последнее положение эха — максимальный frame
                const latestEcho = echoPositions.reduce((a, b) => a.frame > b.frame ? a : b);
                // симулируем падение: если y эха > 610 (ниже смерти), башня дрожит
                if (latestEcho.y > 610) {
                    // эхо упало!
                    shake = 12; // тряска
                    // удаляем все старые точки эха, чтобы оно не триггерило постоянно
                    pathHistory = pathHistory.filter(p => (frame - p.frame) < ECHO_DELAY_FRAMES); 
                    echoPositions = [];
                }
            }

            // подчищаем старую историю (старше 4 секунд, не нужна)
            pathHistory = pathHistory.filter(p => frame - p.frame < 150);
        }

        // обновление камеры — следим за live.y
        function updateCamera() {
            // целевая камера: персонаж примерно в 300px от верха
            let targetCam = live.y - 270;
            targetCam = Math.max(0, Math.min(1000, targetCam)); // ограничим
            cameraY += (targetCam - cameraY) * 0.1;
        }

        // игровой цикл
        function gameLoop() {
            if (!gameOver) {
                applyCollisions();
                updateEcho();
                updateCamera();
                if (shake > 0) shake -= 1;
            } else {
                if (shake > 0) shake -= 1;
            }

            drawCanvas();
            requestAnimationFrame(gameLoop);
        }

        // ---------- отрисовка ----------
        function drawCanvas() {
            ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);
            ctx.save();

            // эффект тряски
            if (shake > 0) {
                let dx = (Math.random() * shake - shake/2) * 1.3;
                let dy = (Math.random() * shake - shake/2) * 1.3;
                ctx.translate(dx, dy);
            }

            // фон градиент (ночь)
            const gradient = ctx.createLinearGradient(0, 0, 0, CANVAS_H);
            gradient.addColorStop(0, '#0c1120');
            gradient.addColorStop(1, '#1b2335');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

            // туман/звёзды
            ctx.fillStyle = '#d4eaff20';
            for (let i=0; i<10; i++) {
                ctx.beginPath();
                ctx.arc(40 + i*31, (i*50 + cameraY*0.1) % 600, 1.5, 0, Math.PI*2);
                ctx.fillStyle = '#bcd5ff30';
                ctx.fill();
            }

            // рисуем платформы (башня) со смещением камеры
            platforms.forEach(p => {
                let yScreen = p.y - cameraY;
                if (yScreen > -20 && yScreen < CANVAS_H + 30) {
                    // свечение
                    ctx.shadowColor = '#7cc7ff';
                    ctx.shadowBlur = 14 * p.glow;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                    ctx.fillStyle = '#b3defa';
                    ctx.beginPath();
                    ctx.roundRect(p.x, yScreen - 2, p.w, p.h+2, 6);
                    ctx.fill();

                    ctx.shadowBlur = 20;
                    ctx.fillStyle = '#f5f9ff';
                    ctx.beginPath();
                    ctx.roundRect(p.x+2, yScreen-2, p.w-4, 4, 4);
                    ctx.fill();

                    // надписи (энергия)
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#f0f4ff';
                    ctx.font = 'bold 8px monospace';
                    ctx.fillText('⬤', p.x + 10, yScreen-6);
                }
            });

            // сброс тени для персонажей
            ctx.shadowBlur = 18;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 2;

            // рисуем Эхо (полупрозрачное, повторяет путь)
            if (echoPositions.length > 0) {
                // сортируем, чтобы рисовать в порядке старения (более старые снизу)
                const sortedEcho = [...echoPositions].sort((a,b) => a.frame - b.frame);
                sortedEcho.forEach((pos, idx) => {
                    let yEcho = pos.y - cameraY;
                    if (yEcho > -20 && yEcho < CANVAS_H+30) {
                        ctx.globalAlpha = 0.4 + 0.1 * Math.sin(frame*0.2 + idx);
                        ctx.shadowColor = '#4db6ac';
                        ctx.fillStyle = '#9ef0e0';
                        ctx.beginPath();
                        ctx.ellipse(pos.x-2, yEcho-4, 10, 12, 0, 0, Math.PI*2);
                        ctx.fill();
                        ctx.fillStyle = '#2c5f5a';
                        ctx.beginPath();
                        ctx.ellipse(pos.x-4, yEcho-8, 4, 6, 0, 0, Math.PI*2);
                        ctx.fill();
                    }
                });
            }

            // рисуем живую Эру
            ctx.globalAlpha = 1.0;
            ctx.shadowColor = '#ffa07a';
            ctx.shadowBlur = 30;
            // тело
            ctx.fillStyle = '#ffc7b1';
            ctx.beginPath();
            ctx.ellipse(live.x-2, live.y-4 - cameraY, 10, 14, 0, 0, Math.PI*2);
            ctx.fill();
            // плащ
            ctx.fillStyle = '#cc6b4f';
            ctx.beginPath();
            ctx.ellipse(live.x-6, live.y-2 - cameraY, 8, 12, 0.1, 0, Math.PI*2);
            ctx.fill();
            // ледоруб
            ctx.fillStyle = '#aaaaaa';
            ctx.shadowBlur = 10;
            ctx.fillRect(live.x+8, live.y-10 - cameraY, 4, 20);

            // индикатор "жива"
            ctx.shadowBlur = 20;
            ctx.fillStyle = '#ffb092';
            ctx.beginPath();
            ctx.arc(live.x-6, live.y-22 - cameraY, 6, 0, Math.PI*2);
            ctx.fill();

            // эффект падения / gameover
            if (gameOver) {
                ctx.globalAlpha = 0.7;
                ctx.fillStyle = '#170f1c';
                ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
                ctx.globalAlpha = 1;
                ctx.fillStyle = 'white';
                ctx.font = 'bold 20px sans-serif';
                ctx.shadowBlur = 30;
                ctx.fillText('Падение', 100, 300 - cameraY);
            }

            ctx.restore();
        }

        // helper для roundRect
        CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            this.moveTo(x + r, y);
            this.lineTo(x + w - r, y);
            this.quadraticCurveTo(x + w, y, x + w, y + r);
            this.lineTo(x + w, y + h - r);
            this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            this.lineTo(x + r, y + h);
            this.quadraticCurveTo(x, y + h, x, y + h - r);
            this.lineTo(x, y + r);
            this.quadraticCurveTo(x, y, x + r, y);
            return this;
        };

        // перезапуск
        restartBtn.addEventListener('click', () => {
            resetGame();
        });

        // старт цикла
        gameLoop();
    })();
</script>
</body>
</html>